/**
 * Template render function signature
 */
export type TemplateRenderFn<TContext> = (ctx: TContext) => { html: string; text: string };

/**
 * Template definition with metadata
 */
export interface TemplateDefinition<TContext = unknown> {
  /** Template name/identifier */
  name: string;
  /** The render function generated by the compiler */
  render: TemplateRenderFn<TContext>;
  /** Default subject line (can be overridden) */
  subject?: string;
}

/**
 * Registry for compiled email templates
 *
 * Provides type-safe access to templates and their context types.
 *
 * @example
 * ```typescript
 * // templates.compiled/index.ts
 * import * as welcomeEmail from './welcome-email.js';
 * import * as passwordReset from './password-reset.js';
 *
 * export const templates = new TemplateRegistry()
 *   .register('welcome', welcomeEmail.render, { subject: 'Welcome!' })
 *   .register('password-reset', passwordReset.render, { subject: 'Reset your password' });
 *
 * // Usage
 * const { html, text } = templates.render('welcome', { name: 'Alice' });
 * ```
 */
export class TemplateRegistry<
  TTemplates extends Record<string, TemplateDefinition> = Record<string, never>,
> {
  private readonly templates: Map<string, TemplateDefinition> = new Map();

  /**
   * Registers a template with the registry
   *
   * @param name - Unique template identifier
   * @param render - The compiled render function
   * @param options - Optional template metadata
   * @returns A new registry with the template added (for chaining)
   */
  register<TName extends string, TContext>(
    name: TName,
    render: TemplateRenderFn<TContext>,
    options?: { subject?: string }
  ): TemplateRegistry<TTemplates & Record<TName, TemplateDefinition<TContext>>> {
    this.templates.set(name, {
      name,
      render: render as TemplateRenderFn<unknown>,
      subject: options?.subject,
    });

    // Return this for chaining (type-safe)
    return this as unknown as TemplateRegistry<
      TTemplates & Record<TName, TemplateDefinition<TContext>>
    >;
  }

  /**
   * Renders a template with the given context
   *
   * @param name - Template name
   * @param context - Template context data
   * @returns The rendered HTML and text
   */
  render<TName extends keyof TTemplates>(
    name: TName,
    context: TTemplates[TName] extends TemplateDefinition<infer TContext> ? TContext : never
  ): { html: string; text: string } {
    const template = this.templates.get(name as string);
    if (!template) {
      throw new Error(`Template "${String(name)}" not found in registry`);
    }
    return template.render(context);
  }

  /**
   * Gets the default subject for a template
   */
  getSubject<TName extends keyof TTemplates>(name: TName): string | undefined {
    const template = this.templates.get(name as string);
    return template?.subject;
  }

  /**
   * Checks if a template exists
   */
  has(name: string): boolean {
    return this.templates.has(name);
  }

  /**
   * Gets all registered template names
   */
  get names(): string[] {
    return [...this.templates.keys()];
  }

  /**
   * Gets the number of registered templates
   */
  get size(): number {
    return this.templates.size;
  }
}

/**
 * Creates a new empty template registry
 */
export function createTemplateRegistry(): TemplateRegistry {
  return new TemplateRegistry();
}
