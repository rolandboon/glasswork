import { tokenize } from './tokenizer.js';
import { extractTypes, generateInterface } from './type-extractor.js';
import type { CompiledTemplate, InferredType } from './types.js';

/**
 * Two-pass MJML template compiler.
 *
 * Pass 1: MJML → HTML (preserving control flow markers in comments)
 * Pass 2: HTML with markers → TypeScript template literal function
 *
 * This approach allows us to:
 * 1. Use the full power of MJML at build time
 * 2. Generate zero-dependency TypeScript render functions
 * 3. Infer TypeScript types from template usage
 */

/**
 * Compiles an MJML template with control flow syntax to a TypeScript render function.
 *
 * @param source - MJML source with control flow markers
 * @param name - Template name (used for interface naming)
 * @param mjmlCompile - MJML compiler function (injected to avoid bundling MJML)
 * @returns Compiled TypeScript source code
 */
export function compile(
  source: string,
  name: string,
  mjmlCompile: (mjml: string) => { html: string; errors: Array<{ message: string }> }
): CompiledTemplate {
  // Pass 1: Compile MJML to HTML (markers are preserved in comments)
  const { html, errors } = mjmlCompile(source);

  if (errors.length > 0) {
    const errorMessages = errors.map((e) => e.message).join('\n');
    throw new Error(`MJML compilation errors:\n${errorMessages}`);
  }

  // Extract subject from <mj-title> in source or <title> in compiled HTML
  const subject = extractSubject(source, html);

  // Tokenize the original source to extract control flow structure and variables
  const tokens = tokenize(source);

  // Extract types from tokens
  const types = extractTypes(tokens);

  // Pass 2: Transform compiled HTML to TypeScript
  const tsSource = generateTypeScriptSource(name, html, tokens, types);

  return {
    source: tsSource,
    contextInterface: generateInterface(`${toPascalCase(name)}Context`, types),
    name,
    subject,
  };
}

/**
 * Extracts subject from MJML source (<mj-title>) or compiled HTML (<title>)
 */
function extractSubject(source: string, html: string): string | undefined {
  // First try to get from <mj-title> in MJML source
  const mjTitleMatch = source.match(/<mj-title>([^<]+)<\/mj-title>/i);
  if (mjTitleMatch) {
    return mjTitleMatch[1].trim();
  }

  // Fall back to <title> in compiled HTML
  const titleMatch = html.match(/<title>([^<]+)<\/title>/i);
  if (titleMatch) {
    return titleMatch[1].trim();
  }

  return undefined;
}

/**
 * Generates TypeScript source code for a compiled template.
 */
function generateTypeScriptSource(
  name: string,
  html: string,
  _tokens: unknown[],
  types: Map<string, InferredType>
): string {
  const interfaceName = `${toPascalCase(name)}Context`;
  const interfaceCode = generateInterface(interfaceName, types);

  // Transform the HTML with control flow markers into template literal
  const transformedHtml = transformHtmlToTemplateLiteral(html);

  return `// This file is auto-generated by @glasswork/email. Do not edit manually.

${interfaceCode}

export function render(ctx: ${interfaceName}): { html: string; text: string } {
  const html = \`${escapeTemplateLiteral(transformedHtml)}\`;

  // Auto-generated plain text version
  const text = htmlToText(html);

  return { html, text };
}

/**
 * Converts HTML to plain text for email clients that don't support HTML.
 */
function htmlToText(html: string): string {
  return html
    // Remove style and script tags with content
    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')
    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')
    // Convert line breaks
    .replace(/<br\\s*\\/?>/gi, '\\n')
    // Convert block elements to newlines
    .replace(/<\\/(p|div|tr|h[1-6])>/gi, '\\n')
    // Convert list items
    .replace(/<li[^>]*>/gi, '• ')
    .replace(/<\\/li>/gi, '\\n')
    // Remove remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    // Clean up whitespace
    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')
    .trim();
}
`;
}

/**
 * Marker interface for control flow markers in HTML
 */
interface Marker {
  type: 'if' | 'elseif' | 'else' | 'each' | 'end';
  match: string;
  index: number;
  condition?: string;
  arrayPath?: string;
  itemName?: string;
  indexName?: string;
}

/**
 * Finds all control flow markers in HTML
 */
function findMarkers(html: string): Marker[] {
  const markers: Marker[] = [];

  // Find @if markers
  const ifPattern = /<!--\s*@if\s+([^-]+?)\s*-->/g;
  let match: RegExpExecArray | null = ifPattern.exec(html);
  while (match !== null) {
    markers.push({
      type: 'if',
      match: match[0],
      index: match.index,
      condition: match[1].trim(),
    });
    match = ifPattern.exec(html);
  }

  // Find @elseif markers
  const elseifPattern = /<!--\s*@elseif\s+([^-]+?)\s*-->/g;
  match = elseifPattern.exec(html);
  while (match !== null) {
    markers.push({
      type: 'elseif',
      match: match[0],
      index: match.index,
      condition: match[1].trim(),
    });
    match = elseifPattern.exec(html);
  }

  // Find @else markers
  const elsePattern = /<!--\s*@else\s*-->/g;
  match = elsePattern.exec(html);
  while (match !== null) {
    markers.push({
      type: 'else',
      match: match[0],
      index: match.index,
    });
    match = elsePattern.exec(html);
  }

  // Find @each markers
  const eachPattern = /<!--\s*@each\s+(\S+)\s+as\s+(\w+)(?:\s*,\s*(\w+))?\s*-->/g;
  match = eachPattern.exec(html);
  while (match !== null) {
    markers.push({
      type: 'each',
      match: match[0],
      index: match.index,
      arrayPath: match[1],
      itemName: match[2],
      indexName: match[3],
    });
    match = eachPattern.exec(html);
  }

  // Find @end markers
  const endPattern = /<!--\s*@end\s*-->/g;
  match = endPattern.exec(html);
  while (match !== null) {
    markers.push({
      type: 'end',
      match: match[0],
      index: match.index,
    });
    match = endPattern.exec(html);
  }

  // Sort markers by position
  markers.sort((a, b) => a.index - b.index);
  return markers;
}

/**
 * Builds a map of loop variables at each marker position
 */
function buildLoopVarScope(markers: Marker[]): Map<number, Set<string>> {
  const loopVarsAtPosition = new Map<number, Set<string>>();
  const tempStack: Array<{ itemName?: string; indexName?: string }> = [];

  for (const marker of markers) {
    if (marker.type === 'each') {
      tempStack.push({ itemName: marker.itemName, indexName: marker.indexName });
    } else if (marker.type === 'end' && tempStack.length > 0) {
      tempStack.pop();
    }

    // Record current loop vars at this position
    const currentLoopVars = new Set<string>();
    for (const ctx of tempStack) {
      if (ctx.itemName) currentLoopVars.add(ctx.itemName);
      if (ctx.indexName) currentLoopVars.add(ctx.indexName);
    }
    loopVarsAtPosition.set(marker.index, currentLoopVars);
  }

  return loopVarsAtPosition;
}

/**
 * Creates replacement for if marker
 */
function createIfReplacement(
  marker: Marker,
  loopVars: Set<string>
): { original: string; replacement: string; index: number } | null {
  if (!marker.condition) {
    return null;
  }
  return {
    original: marker.match,
    replacement: `\${${transformConditionExpr(marker.condition, loopVars)} ? \``,
    index: marker.index,
  };
}

/**
 * Creates replacement for elseif marker
 */
function createElseifReplacement(
  marker: Marker,
  loopVars: Set<string>
): { original: string; replacement: string; index: number } | null {
  if (!marker.condition) {
    return null;
  }
  return {
    original: marker.match,
    replacement: `\` : ${transformConditionExpr(marker.condition, loopVars)} ? \``,
    index: marker.index,
  };
}

/**
 * Creates replacement for each marker
 */
function createEachReplacement(marker: Marker): {
  original: string;
  replacement: string;
  index: number;
} {
  const mapParams = marker.indexName
    ? `(${marker.itemName}, ${marker.indexName})`
    : `(${marker.itemName}, __index)`;
  return {
    original: marker.match,
    replacement: `\${((__array) => __array.map(${mapParams} => \``,
    index: marker.index,
  };
}

/**
 * Creates replacement for end marker
 */
function createEndReplacement(
  marker: Marker,
  block: { type: 'if' | 'each'; arrayPath?: string } | undefined
): { original: string; replacement: string; index: number } | null {
  if (block?.type === 'if') {
    return {
      original: marker.match,
      replacement: "` : ''}",
      index: marker.index,
    };
  }
  if (block?.type === 'each') {
    return {
      original: marker.match,
      replacement: `\`).join(''))(ctx.${block.arrayPath})}`,
      index: marker.index,
    };
  }
  return null;
}

/**
 * Builds replacement array from markers
 */
function buildReplacements(
  markers: Marker[],
  loopVarsAtPosition: Map<number, Set<string>>
): Array<{ original: string; replacement: string; index: number }> {
  const replacements: Array<{ original: string; replacement: string; index: number }> = [];
  const blockStack: Array<{
    type: 'if' | 'each';
    arrayPath?: string;
  }> = [];

  for (const marker of markers) {
    const loopVars = loopVarsAtPosition.get(marker.index) || new Set();

    switch (marker.type) {
      case 'if':
        blockStack.push({ type: 'if' });
        {
          const replacement = createIfReplacement(marker, loopVars);
          if (replacement) {
            replacements.push(replacement);
          }
        }
        break;

      case 'elseif': {
        const replacement = createElseifReplacement(marker, loopVars);
        if (replacement) {
          replacements.push(replacement);
        }
        break;
      }

      case 'else':
        replacements.push({
          original: marker.match,
          replacement: '` : `',
          index: marker.index,
        });
        break;

      case 'each':
        blockStack.push({
          type: 'each',
          arrayPath: marker.arrayPath,
        });
        replacements.push(createEachReplacement(marker));
        break;

      case 'end': {
        const block = blockStack.pop();
        const replacement = createEndReplacement(marker, block);
        if (replacement) {
          replacements.push(replacement);
        }
        break;
      }
    }
  }

  return replacements;
}

/**
 * Applies replacements to HTML string
 */
function applyReplacements(
  html: string,
  replacements: Array<{ original: string; replacement: string; index: number }>
): string {
  let result = html;
  // Apply replacements (in reverse order to preserve indices)
  for (let i = replacements.length - 1; i >= 0; i--) {
    const { original, replacement, index } = replacements[i];
    result = result.slice(0, index) + replacement + result.slice(index + original.length);
  }
  return result;
}

/**
 * Transforms variable interpolations in HTML
 */
function transformVariables(html: string, markers: Marker[]): string {
  // Build final loop variable set from all @each markers
  const allLoopVars = new Set<string>();
  for (const marker of markers) {
    if (marker.type === 'each') {
      if (marker.itemName) allLoopVars.add(marker.itemName);
      if (marker.indexName) allLoopVars.add(marker.indexName);
    }
  }

  // Transform variable interpolations
  return html.replace(/\{\{([^}]+)\}\}/g, (_match, expression) => {
    return transformVariableExpr(expression.trim(), allLoopVars);
  });
}

/**
 * Transforms compiled HTML by replacing control flow markers and variables
 * with JavaScript template literal expressions.
 */
function transformHtmlToTemplateLiteral(html: string): string {
  const markers = findMarkers(html);
  const loopVarsAtPosition = buildLoopVarScope(markers);
  const replacements = buildReplacements(markers, loopVarsAtPosition);
  let result = applyReplacements(html, replacements);
  result = transformVariables(result, markers);
  return result;
}

/**
 * Transforms a condition expression, handling loop context variables.
 */
function transformConditionExpr(condition: string, loopVars: Set<string>): string {
  let result = condition
    .replace(/@index/g, '__index')
    .replace(/@first/g, '(__index === 0)')
    .replace(/@last/g, '(__index === __array.length - 1)')
    .replace(/@length/g, '__array.length');

  // Add ctx. prefix to root-level variables only
  // Match variable paths like "items", "items.length", "user.isAdmin"
  result = result.replace(/\b([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)\b/g, (match, varPath) => {
    const rootVar = varPath.split('.')[0];

    // Don't prefix JS keywords
    if (['true', 'false', 'null', 'undefined', 'length'].includes(rootVar)) {
      return match;
    }

    // Don't prefix internal loop variables
    if (['__index', '__array'].includes(rootVar)) {
      return match;
    }

    // Don't prefix loop item variables
    if (loopVars.has(rootVar)) {
      return match;
    }

    return `ctx.${match}`;
  });

  return result;
}

/**
 * Transforms a variable expression to a template literal expression.
 */
function transformVariableExpr(expression: string, loopVars: Set<string>): string {
  // Check for default value: name ?? 'default'
  const defaultMatch = expression.match(/^(.+?)\s*\?\?\s*['"]([^'"]*)['"]\s*$/);
  if (defaultMatch) {
    const path = defaultMatch[1].trim();
    const defaultValue = defaultMatch[2];
    const rootVar = path.split('.')[0];

    // Check if root is a loop variable
    if (loopVars.has(rootVar)) {
      return `\${${path} ?? '${defaultValue}'}`;
    }
    return `\${ctx.${path} ?? '${defaultValue}'}`;
  }

  // Handle loop context variables (@index, @first, @last, @length)
  if (expression.startsWith('@')) {
    const loopVar = expression.slice(1);
    switch (loopVar) {
      case 'index':
        // biome-ignore lint/suspicious/noTemplateCurlyInString: Intentional - building template literal string
        return '${__index}';
      case 'first':
        // biome-ignore lint/suspicious/noTemplateCurlyInString: Intentional - building template literal string
        return '${__index === 0}';
      case 'last':
        // biome-ignore lint/suspicious/noTemplateCurlyInString: Intentional - building template literal string
        return '${__index === __array.length - 1}';
      case 'length':
        // biome-ignore lint/suspicious/noTemplateCurlyInString: Intentional - building template literal string
        return '${__array.length}';
      default:
        return `\${${loopVar}}`;
    }
  }

  // Handle expressions with operators or loop context
  if (expression.includes('@') || expression.includes('+') || expression.includes('-')) {
    const transformed = expression
      .replace(/@index/g, '__index')
      .replace(/@first/g, '(__index === 0)')
      .replace(/@last/g, '(__index === __array.length - 1)')
      .replace(/@length/g, '__array.length');
    return `\${${transformed}}`;
  }

  // Check if root variable is a loop item variable
  const rootVar = expression.split('.')[0];
  if (loopVars.has(rootVar)) {
    return `\${${expression}}`;
  }

  // Regular context variable
  return `\${ctx.${expression}}`;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s.]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Escapes backticks and dollar signs in template literals.
 */
function escapeTemplateLiteral(str: string): string {
  // We need to escape:
  // 1. Backticks that aren't part of our nested template literals
  // 2. ${} that aren't our intentional interpolations
  // This is tricky because we're generating nested template literals

  // For the spike, we'll escape backticks in the original HTML content
  // Our generated ${...} expressions are already correct
  return str
    .replace(/\\`/g, '\\\\`') // First escape any already-escaped backticks
    .replace(/(?<!\\)\$(?!\{)/g, '\\$'); // Escape $ that isn't part of ${}
}

// Re-export types and utilities
export { tokenize } from './tokenizer.js';
export { extractTypes, generateInterface } from './type-extractor.js';
export type { CompiledTemplate, CompilerOptions, Token } from './types.js';
