import { generateInterface } from './type-extractor.js';
import type { InferredType, Token } from './types.js';

/**
 * Generates TypeScript code from tokenized template.
 * Converts control flow markers and variables to JS template literals.
 */
export function generateCode(
  name: string,
  tokens: Token[],
  types: Map<string, InferredType>,
  html: string
): string {
  const interfaceName = toPascalCase(name) + 'Context';
  const interfaceCode = generateInterface(interfaceName, types);

  // Transform the HTML with control flow markers into template literal
  const transformedHtml = transformToTemplateLiteral(tokens);

  const code = `// This file is auto-generated by @glasswork/email. Do not edit manually.

${interfaceCode}

export function render(ctx: ${interfaceName}): { html: string; text: string } {
  const html = \`${escapeBackticks(transformedHtml)}\`;

  // Auto-generated plain text version
  const text = htmlToText(html);

  return { html, text };
}

function htmlToText(html: string): string {
  return html
    // Remove style and script tags with content
    .replace(/<style[^>]*>[sS]*?</style>/gi, '')
    .replace(/<script[^>]*>[sS]*?</script>/gi, '')
    // Convert line breaks
    .replace(/<br\\s*\\/?>/gi, '\\n')
    // Convert block elements to newlines
    .replace(/<\\/(p|div|tr|h[1-6])>/gi, '\\n')
    // Convert list items
    .replace(/<li[^>]*>/gi, '• ')
    .replace(/<\\/li>/gi, '\\n')
    // Remove remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    // Clean up whitespace
    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')
    .trim();
}
`;

  return code;
}

/**
 * Transforms tokens back into a string with JS template literal expressions.
 */
function transformToTemplateLiteral(tokens: Token[]): string {
  const parts: string[] = [];
  const blockStack: Array<'if' | 'each'> = [];

  for (const token of tokens) {
    switch (token.type) {
      case 'text':
        parts.push(token.content);
        break;

      case 'variable':
        parts.push(transformVariable(token));
        break;

      case 'if':
        blockStack.push('if');
        parts.push(`\${${transformCondition(token.condition)} ? \``);
        break;

      case 'elseif':
        // Close previous if/elseif block and start new conditional
        parts.push(`\` : ${transformCondition(token.condition)} ? \``);
        break;

      case 'else':
        // Close previous if/elseif block and start else
        parts.push('` : `');
        break;

      case 'each':
        blockStack.push('each');
        parts.push(transformEachStart(token));
        break;

      case 'end': {
        const blockType = blockStack.pop();
        if (blockType === 'if') {
          // Close conditional - if no else was provided, use empty string
          parts.push("` : ''}");
        } else if (blockType === 'each') {
          parts.push("`).join('')}");
        }
        break;
      }
    }
  }

  return parts.join('');
}

function transformVariable(token: {
  path: string[];
  defaultValue?: string;
  expression: string;
}): string {
  const path = token.path.join('.');

  // Handle loop context variables
  if (token.path[0].startsWith('@')) {
    const loopVar = token.path[0].slice(1); // Remove @ prefix
    switch (loopVar) {
      case 'index':
        return '${__index}';
      case 'first':
        return '${__index === 0}';
      case 'last':
        return '${__index === __array.length - 1}';
      case 'length':
        return '${__array.length}';
      default:
        return `\${${loopVar}}`;
    }
  }

  // Handle expressions with operators (like @index + 1)
  if (token.expression.includes('+') || token.expression.includes('-')) {
    const transformed = token.expression
      .replace(/@index/g, '__index')
      .replace(/@first/g, '(__index === 0)')
      .replace(/@last/g, '(__index === __array.length - 1)')
      .replace(/@length/g, '__array.length');
    return `\${${transformed}}`;
  }

  if (token.defaultValue !== undefined) {
    return `\${${path} ?? '${token.defaultValue}'}`;
  }

  return `\${${path}}`;
}

function transformCondition(condition: string): string {
  // Transform loop context variables in conditions
  return condition
    .replace(/@index/g, '__index')
    .replace(/@first/g, '(__index === 0)')
    .replace(/@last/g, '(__index === __array.length - 1)')
    .replace(/@length/g, '__array.length');
}

function transformEachStart(token: {
  arrayPath: string;
  itemName: string;
  indexName?: string;
}): string {
  const { arrayPath, itemName, indexName } = token;

  // Build the map function with proper destructuring
  const mapParams = indexName ? `(${itemName}, ${indexName})` : `(${itemName}, __index)`;

  // Store array reference for @last, @length access
  return `\${(((__array) => __array.map(${mapParams} => \``;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function escapeBackticks(str: string): string {
  // Escape backticks that aren't part of our template expressions
  // We need to be careful not to escape the ones we're inserting
  return str.replace(/`/g, '\\`');
}

/**
 * Alternative code generator that produces cleaner output for simple templates
 */
export function generateCodeWithContext(
  name: string,
  compiledHtml: string,
  tokens: Token[],
  types: Map<string, InferredType>
): string {
  const interfaceName = toPascalCase(name) + 'Context';
  const interfaceCode = generateInterface(interfaceName, types);

  // Replace control flow markers and variables in the compiled HTML
  const transformedHtml = transformCompiledHtml(compiledHtml, tokens);

  const code = `// This file is auto-generated by @glasswork/email. Do not edit manually.

${interfaceCode}

export function render(ctx: ${interfaceName}): { html: string; text: string } {
  const html = \`${escapeBackticks(transformedHtml)}\`;

  // Auto-generated plain text version
  const text = htmlToText(html);

  return { html, text };
}

function htmlToText(html: string): string {
  return html
    // Remove style and script tags with content
    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')
    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')
    // Convert line breaks
    .replace(/<br\\s*\\/?>/gi, '\\n')
    // Convert block elements to newlines
    .replace(/<\\/(p|div|tr|h[1-6])>/gi, '\\n')
    // Convert list items
    .replace(/<li[^>]*>/gi, '• ')
    .replace(/<\\/li>/gi, '\\n')
    // Remove remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    // Clean up whitespace
    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')
    .trim();
}
`;

  return code;
}

/**
 * Transforms compiled HTML (from MJML) by replacing markers with template expressions.
 * This is the second pass of the two-pass compilation.
 */
function transformCompiledHtml(html: string, tokens: Token[]): string {
  // Build a map of original positions to replacements
  // Since MJML compilation may have moved things around, we use regex to find markers

  let result = html;

  // Transform control flow markers (they're preserved in HTML comments)
  result = result.replace(/<!--\s*@if\s+([^-]*?)\s*-->/g, (_match, condition) => {
    return `\${${transformCondition(condition.trim())} ? \``;
  });

  result = result.replace(/<!--\s*@elseif\s+([^-]*?)\s*-->/g, (_match, condition) => {
    return `\` : ${transformCondition(condition.trim())} ? \``;
  });

  result = result.replace(/<!--\s*@else\s*-->/g, '` : `');

  // Handle @each - need to track which @end belongs to which @each/@if
  const eachPattern = /<!--\s*@each\s+(\S+)\s+as\s+(\w+)(?:\s*,\s*(\w+))?\s*-->/g;
  result = result.replace(eachPattern, (_match, arrayPath, itemName, indexName) => {
    const mapParams = indexName ? `(${itemName}, ${indexName})` : `(${itemName}, __index)`;
    return `\${(((__array) => __array.map(${mapParams} => \``;
  });

  // Handle @end markers - need context to know if it's if or each
  // For simplicity in spike, we'll use a simple approach
  result = transformEndMarkers(result);

  // Transform variables
  result = result.replace(/\{\{([^}]+)\}\}/g, (_match, expression) => {
    const trimmed = expression.trim();

    // Check for default value
    const defaultMatch = trimmed.match(/^(.+?)\s*\?\?\s*['"]([^'"]*)['"]\s*$/);
    if (defaultMatch) {
      return `\${${defaultMatch[1].trim()} ?? '${defaultMatch[2]}'}`;
    }

    // Handle loop context variables
    if (trimmed.startsWith('@')) {
      const loopVar = trimmed.slice(1);
      switch (loopVar) {
        case 'index':
          return '${__index}';
        case 'first':
          return '${__index === 0}';
        case 'last':
          return '${__index === __array.length - 1}';
        case 'length':
          return '${__array.length}';
      }
    }

    // Handle expressions with loop context
    if (trimmed.includes('@')) {
      const transformed = trimmed
        .replace(/@index/g, '__index')
        .replace(/@first/g, '(__index === 0)')
        .replace(/@last/g, '(__index === __array.length - 1)')
        .replace(/@length/g, '__array.length');
      return `\${${transformed}}`;
    }

    return `\${ctx.${trimmed}}`;
  });

  return result;
}

/**
 * Transforms @end markers based on context.
 * This is tricky because we need to know if it ends an @if or @each.
 */
function transformEndMarkers(html: string): string {
  // Track block types as we encounter them
  const blockStack: Array<'if' | 'each'> = [];
  const markers: Array<{
    type: 'if' | 'elseif' | 'else' | 'each' | 'end';
    index: number;
    length: number;
  }> = [];

  // Find all markers
  const markerPattern = /<!--\s*@(if|elseif|else|each|end)(?:\s+[^-]*?)?\s*-->/g;
  let match: RegExpExecArray | null;

  while ((match = markerPattern.exec(html)) !== null) {
    const type = match[1] as 'if' | 'elseif' | 'else' | 'each' | 'end';
    markers.push({ type, index: match.index, length: match[0].length });
  }

  // Process markers in order and build replacement map
  const replacements: Array<{ index: number; length: number; replacement: string }> = [];

  for (const marker of markers) {
    if (marker.type === 'if') {
      blockStack.push('if');
    } else if (marker.type === 'each') {
      blockStack.push('each');
    } else if (marker.type === 'end') {
      const blockType = blockStack.pop();
      if (blockType === 'if') {
        replacements.push({
          index: marker.index,
          length: marker.length,
          replacement: "` : ''}",
        });
      } else if (blockType === 'each') {
        replacements.push({
          index: marker.index,
          length: marker.length,
          replacement: "`).join('')})(ctx." + findArrayPath(markers, replacements.length) + ')}', // This is simplified
        });
      }
    }
  }

  // Apply replacements in reverse order to preserve indices
  let result = html;
  for (let i = replacements.length - 1; i >= 0; i--) {
    const { index, length, replacement } = replacements[i];
    result = result.slice(0, index) + replacement + result.slice(index + length);
  }

  return result;
}

// Helper to find the array path for an @each block
function findArrayPath(markers: Array<{ type: string }>, endIndex: number): string {
  // This is a simplified version - in a real implementation we'd track this properly
  return 'items';
}
